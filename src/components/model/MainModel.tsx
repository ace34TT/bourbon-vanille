/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { MutableRefObject, useLayoutEffect, useRef, useState } from "react";
import gsap from "gsap";
import { useFrame } from "react-three-fiber";
import { OrthographicCamera as OrthographicCameraType } from "three";
type GLTFResult = GLTF & {
  nodes: {
    Circle035: THREE.Mesh;
    Circle030: THREE.Mesh;
  };
  materials: {
    ["Sisal Rope"]: THREE.MeshStandardMaterial;
    ["Stylized Tree Truck"]: THREE.MeshStandardMaterial;
  };
};

interface ModelProps {
  cameraRef: MutableRefObject<OrthographicCameraType | undefined>;
  containerRef: any;
  [key: string]: any; // This line allows any other property
}
export function Model({ cameraRef, containerRef, ...props }: ModelProps) {
  const { nodes, materials } = useGLTF(
    "models/Vanilla-transformed.glb"
  ) as GLTFResult;
  const modelRef = useRef<THREE.Group>(null);
  const [scrollOffset, setScrollOffset] = useState(0);
  const tl = useRef<GSAPTimeline>();
  useFrame(() => {
    if (!tl.current) return;
    tl.current.seek(scrollOffset * tl.current.duration());
  });
  useLayoutEffect(() => {
    if (!modelRef.current || !cameraRef.current) return;
    tl.current = gsap.timeline();
    tl.current.to(
      modelRef.current.position,
      { duration: 1, x: -0.5, y: -0.1, z: -5 },
      0
    );
    tl.current.to(
      cameraRef.current,
      {
        duration: 1,
        zoom: 900,
        onUpdate: () => {
          cameraRef.current!.updateProjectionMatrix();
        },
      },
      0
    );
    tl.current.to(
      modelRef.current.rotation,
      { duration: 1, x: Math.PI / 12, y: Math.PI / 6, z: -2.75 },
      0
    );
    //
    tl.current.to(
      modelRef.current.rotation,
      { duration: 1, y: -Math.PI / 12 },
      1
    );
    //
    tl.current.to(
      modelRef.current.position,
      { duration: 1, x: -0.5, y: 0, z: -5 },
      2
    );
    tl.current.to(
      modelRef.current.rotation,
      { duration: 1, y: Math.PI / 16 },
      2
    );
    //
    tl.current.to(
      modelRef.current.position,
      { duration: 1, x: -0.5, y: -0.3, z: -5 },
      3
    );
    //
    tl.current.to(
      modelRef.current.position,
      { duration: 1, x: 0, y: -0.2, z: -5 },
      4
    );
    tl.current.to(
      modelRef.current.rotation,
      { duration: 1, y: Math.PI, x: Math.PI / 6 },
      4
    );
    tl.current.to(
      cameraRef.current,
      {
        duration: 1,
        zoom: 300,
        onUpdate: () => {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          cameraRef.current!.updateProjectionMatrix();
        },
      },
      4
    );

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const handleScroll = () => {
    const { scrollTop, clientHeight } = document.documentElement;
    const newScrollOffset = scrollTop / (clientHeight * 5 - clientHeight);
    setScrollOffset(newScrollOffset);
  };
  useLayoutEffect(() => {
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);
  return (
    <group
      {...props}
      dispose={null}
      scale={[0.07, 0.07, 0.04]}
      ref={modelRef}
      position={[0.75, -0.8, -5]}
      rotation={[0.003, 0.651, -3.13]}
    >
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Circle035.geometry}
        material={materials["Sisal Rope"]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Circle030.geometry}
        material={materials["Stylized Tree Truck"]}
      />
    </group>
  );
}

useGLTF.preload("models/Vanilla-transformed.glb");
